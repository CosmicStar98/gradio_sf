--@name Gamer Radio V3
--@author CosmicStar98 [STEAM_0:0:634049946]
--@shared
--@include ./mp/musicplayer_libs.txt
--@include ./mp/musicplayer_songlist.txt
//-g-@model models/props/cs_office/radio.mdl
--@model models/props_lab/citizenradio.mdl
//-g-@model models/props_radiostation/radio_antenna01.mdl

require("./mp/musicplayer_libs.txt") -- Load the dependencies

radioCFG = {
    ["prefix"] = "?",
    ["global_aud"] = 0,
    ["playlist"] = "default"    -- enter "default" for standard playlist or enter a pastebin url with properly formatted contents
}
cmd_prefix = radioCFG["prefix"] -- Global so that this is accessible by musicplayer_libs.txt

local defaultVALs = {
    ["pitch"] = 0,
    ["volume"] = 1.3,
    ["radius"] = 150
}


-- [START] do not modify!!!

-- Data for various commands
local song_length = nil
local curr_pitch = defaultVALs["pitch"]
local curr_volume = defaultVALs["volume"]
local curr_radius = defaultVALs["radius"]

local i = 1
local num_id = 1

local isPaused = 0

-- [END] do not modify!!!


local SongList = require("./mp/musicplayer_songlist.txt") -- Default song playlist (IMPORTANT: do not publish your own FROM CLOUD SERVICES LIKE GDRIVE, as your files/account may get rate limited or flagged as bot activity from mass public use!)


if SERVER then
    registerCommand("next", function(ply, args)
        local inputVal = tonumber(args[2])
        if not inputVal then inputVal = 1 end

        net.start("skipSong")
          net.writeDouble(inputVal)
        net.send()
    end, {"n", "skip"})

    registerCommand("prev", function(ply, args)
        local inputVal = tonumber(args[2])
        if not inputVal then inputVal = 1 end

        net.start("prevSong")
          net.writeDouble(inputVal)
        net.send()
    end, {"b", "back"})

    registerCommand("load", function(ply, args)
        local songID = tonumber(args[2])
        if songID then
            net.start("loadID")
              net.writeDouble(songID)
            net.send()
        end
    end, {"l", "jump", "play"})

    registerCommand("time", function(ply, args)
        if args[2]:sub(1,1) == "-" or args[2]:sub(1,1) == "+" then
            inputType = args[2]:sub(1,1)
            inputVal = tonumber(args[2]:sub(2))
        else
            inputType = ""
            inputVal = tonumber(args[2])
        end

        if not args[2] then
            inputType = ""
            inputVal = 10
        end

        net.start("songTime")
          net.writeString(inputType)
          net.writeDouble(inputVal)
        net.send()
    end, {"t", "pos", "position"})

    registerCommand("pitch", function(ply, args)
        local inputVal = tonumber(args[2])
        if not inputVal then inputVal = defaultVALs["pitch"] end

        net.start("songPitch")
          net.writeDouble(inputVal)
          curr_pitch = inputVal
        net.send()
    end, {"s", "speed"})

    registerCommand("volume", function(ply, args)
        local inputVal = tonumber(args[2])
        if not inputVal then inputVal = defaultVALs["volume"] end

        net.start("songVolume")
          net.writeDouble(inputVal)
          curr_volume = inputVal
        net.send()
    end, {"v", "vol"})

    registerCommand("radius", function(ply, args)
        local inputVal = tonumber(args[2])
        if not inputVal then inputVal = defaultVALs["radius"] end

        if radioCFG["global_aud"] == 0 then
            net.start("songRadius")
              net.writeDouble(inputVal)
              curr_radius = inputVal
            net.send()
        end
    end, {"r", "d", "range", "dist"})

    registerCommand("pause", function(ply, args)
        net.start("pauseSong")
        net.send()
    end, {"p"})
    registerCommand("unpause", function(ply, args)
        net.start("force_unpauseSong")
        net.send()
    end, {"up"})

    registerCommand("global", function(ply, args)
        net.start("songGlobal")
        net.send()
    end, {"g", "no3d"})

    registerCommand("reload", function(ply, args)
        net.start("reload")
        net.send()
    end, {"r", "restart", "refresh"})

    registerCommand("loop", function(ply, args)
        net.start("loop")
        net.send()
    end, {"repeat"})


    hook.add("PlayerSay", "ChatCommands", processChatCommand)
    hook.add("think", "ChipTweaks", function()
        if isValid(chip()) then
            chip():enableMotion(false)
            chip():setDrawShadow(false)
        end
    end)
    hook.add("PhysgunPickup", "AllowPickup", function(ply, ent)
        if isValid(chip()) then return false end
    end)
    hook.add("EntityTakeDamage", "NoChipDamage", function()
        if isValid(chip()) then return false end
    end)
    --[[ hook.add("OnPhysgunPickup", "FuckOff", function(ply, ent)
        if isValid(chip()) and ply ~= owner() then
            ply:stripWeapons()
        end
    end) ]]
else
    local function loadSong(songURL)
        bass.loadURL(tostring(songURL), "3d noblock", function(snd, err, errtxt)
            if snd then
                pcall(snd.setLooping, snd, true)
            end

            if isValid(snd) then
                snd:setVolume(curr_volume)
                snd:setFade(curr_radius, curr_radius)
            end

            -- Flush the previously created timers on each execution to avoid hitting the timer limit
            if timer.exists("startstop") then
                timer.remove("startstop")
            end
            if timer.exists("loadsong") then
                timer.remove("loadsong")
            end

            if isValid(snd) then     
                local len = snd:getLength()
                local dur = snd:getTime()

                song_length = len

                setName(string.format("â™ª Super Boombox DX â™ª ]\n[   %s by %s   ]\n[   ID #%i   ]\n[  %i Songs Loaded ", SongList[i]["name"], SongList[i]["artist"], i, #SongList))

                if i > #SongList then i = 1 end
                if len == nil then
                    if i >= #SongList then i = 1 else i = i + 1 end
                    loadSong(SongList[i]["url"])
                end

                -- Recreate the timers only if the audio is valid
                timer.create("startstop", len, 1, function()
                    if snd then snd:stop() end
                end)
                timer.create("loadsong", len, 1, function()
                    if i >= #SongList then i = 1 else i = i + 1 end
                    loadSong(SongList[i]["url"])
                end)

                net.receive("skipSong", function(res)
                    local num_next = net.readDouble()
                    if num_next == nil or num_next <= 0 then return "" end
                    if num_next > 15 then num_next = 15 end

                    timer.stop("startstop")
                    timer.stop("loadsong")

                    timer.adjust("startstop", len, 1, function()
                        if snd then snd:stop() end
                    end)

                    timer.adjust("loadsong", len, 1, function()
                        if i >= #SongList then 
                            i = 1 
                        else 
                            i = i + 1 
                        end
                        loadSong(SongList[i]["url"])
                    end)

                    if snd then snd:stop() end

                    i = i + num_next
                    if i > #SongList then
                        i = ((i - 1) % #SongList) + 1
                    end

                    loadSong(SongList[i]["url"])
                end)

                net.receive("prevSong", function(res)
                    local num_prev = net.readDouble()
                    if num_prev < 1 then return "" end
                    if num_prev > 15 then num_prev = 15 end
                    if num_prev == nil then num_prev = 1 end

                    timer.stop("startstop")
                    timer.stop("loadsong")

                    timer.adjust("startstop", len, 1, function()
                        if snd then snd:stop() end
                    end)
                    timer.adjust("loadsong", len, 1, function()
                        if i >= #SongList then i = 1 else i = i + 1 end
                        loadSong(SongList[i]["url"])
                    end)
                    
                    if snd then snd:stop() end

                    i = i - num_prev

                    if i < 1 then 
                        i = #SongList + i
                    end

                    loadSong(SongList[i]["url"])
                end)

                net.receive("loadID", function(res)
                    num_id = net.readDouble()
                    if num_id > #SongList then num_id = 1 end
                    if num_id < 1 then num_id = #SongList end
                    if num_id == nil then num_id = 1 end

                    timer.stop("startstop")
                    timer.stop("loadsong")
                        timer.adjust("startstop", len, 1, function()
                            if snd then snd:stop() end
                        end)
                        timer.adjust("loadsong", len, 1, function()
                            if i >= #SongList then i = 1 else i = i + 1 end
                            loadSong(SongList[i]["url"])
                        end)
                    if snd then snd:stop() end
                    i = num_id

                    loadSong(SongList[i]["url"])
                end)

                net.receive("pauseSong", function(res)
                    isPaused = isPaused == 1 and 0 or 1

                    if isPaused == 1 then
                        if snd then snd:pause() end
                        timer.pause("startstop")
                        timer.pause("loadsong")
                    else
                        if snd then snd:play() end
                        timer.unpause("startstop")
                        timer.unpause("loadsong")
                    end
                end)

                net.receive("force_unpauseSong", function(res)
                    if isPaused == 1 then
                        if snd then snd:play() end
                        timer.unpause("startstop")
                        timer.unpause("loadsong")
                    end
                end)

                net.receive("songTime", function(res)
                    local type = net.readString()
                    local time = net.readDouble()
                    if time <= 0 then time = 0 end
                    if time >= math.floor(math.abs(len)) then time = 0 end

                    if type == "+" then
                        if snd:getTime() + time >= math.floor(math.abs(len)) then
                            time = 0
                        else time = snd:getTime() + time end
                    elseif type == "-" then
                        if snd:getTime() - time < 0 then
                            time = snd:getTime()
                        else time = snd:getTime() - time end
                    else time = net.readDouble() end

                    snd:setTime(time, false)
                end)

                net.receive("songPitch", function(res)
                    local pitch = net.readDouble()
                    if pitch == nil or not pitch then pitch = defaultVALs["pitch"] end

                    print("\nâ™« Pitch changed to "..pitch.."!")
                    curr_pitch = pitch
                    if snd then snd:setPitch(pitch) end
                end)

                net.receive("songVolume", function(res)
                    local volume = net.readDouble()
                    if volume == nil or not volume then volume = defaultVALs["volume"] end

                    print("\nâ™« Volume changed to "..volume.."!")
                    curr_volume = volume
                    if snd then snd:setVolume(volume) end
                end)

                if radioCFG["global_aud"] == 0 then
                    net.receive("songRadius", function(len)
                        local radius = net.readDouble()
                        if radius == nil or not radius then radius = defaultVALs["radius"] end

                        print("\nâš ï¸Ž Radius changed to "..radius.."!")
                        curr_radius = radius
                        if snd then snd:setFade(radius, radius) end
                    end)
                end

                net.receive("songGlobal", function(res)
                    if radioCFG["global_aud"] == 1 then radioCFG["global_aud"] = 0 else radioCFG["global_aud"] = 1 end
                end)

                net.receive("reload", function(res)
                    print("\nâš ï¸Ž Reloaded the chip!")

                    if timer.exists("startstop") then timer.remove("startstop") end
                    if timer.exists("loadsong") then timer.remove("loadsong") end

                    i = i
                    num_id = i
                    if snd then snd:stop() end

                    loadSong(SongList[i]["url"])
                end)

                net.receive("loop", function(res)
                    print("\nâ™« Looping #"..i.."!")

                    if timer.exists("startstop") then
                        timer.remove("startstop")
                    end
                    if timer.exists("loadsong") then
                        timer.remove("loadsong")
                    end

                    timer.create("startstop", len, 0, function() snd:setTime(0, false) end)
                    timer.adjust("startstop", len, 1, function()
                        i = i
                        snd:setTime(0, false)
                    end)
                    timer.create("loadsong", len, 0, function() snd:setTime(0, false) end)
                    timer.adjust("loadsong", len, 1, function()
                        i = i
                        snd:setTime(0, false)
                    end)

                    i = i

                    snd:setTime(0, false)
                end)

                hook.add("think", "snd", function()
                    if snd == nil or not snd:isValid() then return end
                    if isValid(snd) and isValid(chip()) then
                        if radioCFG["global_aud"] == 0 then
                            snd:setPos(chip():getPos())
                            if player():getPos():getDistance(chip():getPos()) > curr_radius then
                                snd:setVolume(0)
                            else
                                snd:setVolume(curr_volume)
                            end
                        else
                            snd:setPos(player():getPos())
                        end
                    end
                end)
            else
                print("ðŸ›ˆ "..errtxt..": "..err)
            end
        end)

        url = nil
    end

    print([[
     Welcome to the radio!
      > Heres the list of available commands:

    - ?load <NUMBER>  ::  Jumps to a song id in the playlist
    - ?back, ?next <NUMBER>  ::  FF or RW the curr song
    - ?vol <NUMBER>  ::  Changes the radio's curr volume
    - ?pitch <NUMBER>  ::  Changes the speed of the audio
    - ?radius <NUMBER>  ::  Changes the max audio distance
    - ?global  ::  Play across the map regardless of radius
    - ?loop  ::  Loops the current song until you change tracks
    ]])


    if song_length == nil then
        if radioCFG["playlist"]:lower() == "default" then
                SongList = DefaultPlaylist
                loadSong(SongList[1]["url"])
                print("\nðŸ›ˆ Loaded default playlist!")
        else
            if http.canRequest() then
                local playlist = radioCFG["playlist"]

                local function onSuccess(response, success)
                    SongList = convertToTable(response)
                    loadSong(SongList[1]["url"])
                    print("\nðŸ›ˆ Loaded custom playlist!")
                end

                local function onFailure(error)
                    print(error)
                    SongList = DefaultPlaylist
                    print("\nðŸ›ˆ Loaded default playlist!")
                end

                if string.startWith(playlist, "http") then
                    playlist = FixPlaylistUrl(playlist)
                end

                http.get(playlist:gsub("^https?://", ""), onSuccess, onFailure, {["Content-Type"] = "text/*"})
            else
                print("ðŸ›ˆ Unable to load custom playlist, falling back to default: Disallowed")
            end
        end
    end

    --[[ setupPermissionRequest({"bass.loadURL"}, "Let the radio use mp3 files from external sites", true)

    hook.add("permissionrequest", "permission", function()
        if hasPermission("bass.loadURL", url) then
            loadSong(url)
        else
            print("ðŸ›ˆ Permission Denied")
        end
    end) ]]
end
