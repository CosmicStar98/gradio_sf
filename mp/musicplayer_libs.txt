--@shared
--@include ../musicplayer.txt


local commands = {}
local aliases = {}

--[[

EXAMPLE USAGE:

registerCommand("example_cmd", function(ply, args)
    local inputVal = args[2]

    net.start("soomething")
    net.send()
end, {"alias1", "alias2"}) -- Aliases are like nicknames for the actual command

]]

function registerCommand(name, func, aliasList)
    name = name:lower()
    commands[cmd_prefix .. name] = func

    if aliasList then -- TODO: program feature to allow aliases to extend the original command to allow for additional features per alias (Low priority)
        for _, alias in ipairs(aliasList) do
            if alias:lower() ~= name then -- if the alias is the same as the regular command for some reason then don't add to the list
                aliases[cmd_prefix .. alias] = cmd_prefix .. name
            end
        end
    end
end

function processChatCommand(ply, text, teamChat)
    if not ply == owner() then return end
    if not isLoading == false then return end

    local args = string.explode(" ", text)
    local cmd = args[1]:lower()

    -- Check if the command is an alias and resolve it
    if aliases[cmd] then
        cmd = aliases[cmd]:lower()
    end

    if commands[cmd] then
        commands[cmd](ply, args)
        return ""
    end
end

function FixUrl(url)
    url = url:Trim():gsub("[\"'<>\n\\]+", "")

    if url:find("dropbox", 1, true) then
        url = url:gsub([[^http%://dl%.dropboxusercontent%.com/]], [[https://dl.dropboxusercontent.com/]])
        url = url:gsub([[^https?://dl.dropbox.com/]], [[https://www.dropbox.com/]])
        url = url:gsub([[^https?://www.dropbox.com/s/(.+)%?dl%=[01]$]], [[https://dl.dropboxusercontent.com/s/%1]])
        url = url:gsub([[^https?://www.dropbox.com/s/(.+)$]], [[https://dl.dropboxusercontent.com/s/%1]])
        url = url:gsub([[^https?://www.dropbox.com/scl/(.+)$]], [[https://dl.dropboxusercontent.com/scl/%1]]) -- Fix for new dropbox format.
        return url
    end

    if url:find("drive.google.com", 1, true) and not url:find("export=download", 1, true) then
        local id =
            url:match("https://drive.google.com/file/d/(.-)/") or
            url:match("https://drive.google.com/file/d/(.-)$") or
            url:match("https://drive.google.com/open%?id=(.-)$")

        if id then
            return "https://drive.google.com/uc?export=download&id=" .. id
        end
        return url
    end

    if url:find("gitlab.com", 1, true) then
        return url:gsub("^(https?://.-/.-/.-/)blob", "%1raw")
    end

    url = url:gsub([[^http%://onedrive%.live%.com/redir?]],[[https://onedrive.live.com/download?]])
    url = url:gsub("pastebin.com/([a-zA-Z0-9]*)$", "pastebin.com/raw/%1")
    -- url = url:gsub("github.com/([a-zA-Z0-9_]+)/([a-zA-Z0-9_]+)/blob/", "github.com/%1/%2/raw/")

    return url
end

function FixPlaylistUrl(url)
    url = url:Trim():gsub("[\"'<>\n\\]+", "")


    if url:find("gitlab.com", 1, true) then
        return url:gsub("^(https?://.-/.-/.-/)blob", "%1raw")
    end

    url = url:gsub("pastebin.com/([a-zA-Z0-9]*)$", "pastebin.com/raw/%1")

    return url
end



-- Playlist parser
-- Example input:
-- >Example1|Example2|Example3,Example4|Example5|Example6,Example7|Example8|Example9<
-- The required order to follow is: song's name, author, link to file
-- CASE SENSITIVE. CHECK YOUR SHIT BEFORE COMPLAINING YOUR PLAYLIST DOESN'T WORK
-- LARGE PLAYLISTS MAY TAKE LONGER TO PROCESS!!
function convertToTable(input)
    local result = {}
    --local currentKey = -1
    local currentKey = 0
    local currentEntry = {}
    input = input:gsub("[<>]", "")

    local keys = {}
    for key in input:gmatch("[^,]+") do
        table.insert(keys, key)
    end

    for _, key in ipairs(keys) do
        local entries = {}
        for entry in key:gmatch("[^|]+") do
            table.insert(entries, entry)
        end

        currentKey = currentKey + 1
        currentEntry = {}
        currentEntry["name"] = entries[1] or "Unknown"
        currentEntry["artist"] = entries[2] or "Unknown"
        currentEntry["url"] = FixUrl(entries[3]) or "Unknown"

        result[currentKey] = currentEntry
    end

    return result
end